<html>
  <head>
    <meta charset="UTF-8">
    <title>Digikortti Mikolle</title>
    <style>
      body { background-color: #000000; }
      canvas { background-color: #222222; }
    </style>
  </head>
  <body onload="init();">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
      <script src="assets/pixi-sound.js"></script>
      <div align="center">
        <canvas id="game-canvas" width="800" height="600"></canvas>
      </div>
      <script>

      function getRandomInt(max) {
        return Math.floor(Math.random() * Math.floor(max));
      }

      function init() {
        console.log("init() successfully called.");

       PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;

        // Create the application
        app = new PIXI.Application({view:document.getElementById("game-canvas"), backgroundColor:0xffffff});

        mikkoSprite = PIXI.Sprite.from('assets/mikko_256x256.png');
        mikkoSprite.x = 0;
        mikkoSprite.y = 100;
        mikkoSprite.scale.x = 2.0;
        mikkoSprite.scale.y = 2.0;

        mountainSprite = PIXI.Sprite.from('assets/panorama.png');
        mountainSprite.x = 0;
        mountainSprite.y = -80;
        mountainSprite.scale.x = 10.0;
        mountainSprite.scale.y = 10.0;

        textParkPosition = -1500
        textParkEndPosition = 1500
        textFrontPosition = 200
        textTimer = 0
        textTimeToFront = 1
        textTimeAtFront = 5
        textTimeAtPark = 1
        textPhase = 0

        textIx = 0
        message = []
        message.push('NÄHDÄÄN MIKKO');
        message.push('   SEIKKAILU');
        message.push('    ODOTTAA');
        message.push('  JA DIGITIIMI');
        text = new PIXI.Text(message[0],{fontFamily : 'Arial', fontSize: 52, fill : 0xeeffee, 
          align : 'center'});
        text.x = textParkPosition

        app.stage.addChild(mountainSprite);

        flakes = []

        snow_container_behind = new PIXI.ParticleContainer(50, {
                                        scale: true,
                                        position: true,
                                        alpha: true,
                                    });
        snow_container_front = new PIXI.ParticleContainer(100, {
                                        scale: true,
                                        position: true,
                                        alpha: true,
                                    });
        for (let i = 0; i < 50; ++i)
        {
            const sprite = new PIXI.Sprite.from("assets/snow.png");
            sprite.x = getRandomInt(800);
            sprite.y = getRandomInt(600);
            sprite.speed = Math.random()*0.75 + 0.25
            snow_container_behind.addChild(sprite);
            flakes.push(sprite);
        }
        app.stage.addChild(snow_container_behind);
        app.stage.addChild(mikkoSprite);

        snow_container_front = new PIXI.ParticleContainer();
        
        for (let i = 0; i < 100; ++i)
        {
            const sprite = new PIXI.Sprite.from("assets/snow.png");
            sprite.x = getRandomInt(800);
            sprite.y = getRandomInt(600);
            sprite.scale.x = Math.random()+1
            sprite.scale.y = Math.random()+1
            sprite.speed = Math.random()*0.75 + 0.25
            snow_container_front.addChild(sprite);
            flakes.push(sprite);
        }
        app.stage.addChild(snow_container_front);

        app.stage.addChild(text);

        currentTime = 0

        ticker = new PIXI.Ticker();
        ticker.start();

        PIXI.sound.Sound.from({
            url: 'assets/musa.mp3',
            autoPlay: true,
            complete: function() {
                console.log('Sound finished');
            }
        });

        mountainDir = -1;

        requestAnimationFrame(update);

      }
      function update() {

        textTimer += ticker.elapsedMS*1e-3;
        text.y = 70 + Math.sin(currentTime*2e-4*Math.PI*2.0+1)*30;
        switch(textPhase)
        {
          case 0: {
              text.alpha = textTimer / textTimeToFront;
              text.x = textTimer * textFrontPosition / textTimeToFront;
              if (textTimer > textTimeToFront) 
              {
                textTimer = 0;
                textPhase += 1;
              }
              break;
            }
          case 1: {
              if (textTimer > textTimeAtFront) 
              {
                textTimer = 0;
                textPhase += 1;
              }
              break;
            }
          case 2: {
              text.x = textFrontPosition + (textParkEndPosition - textFrontPosition) * textTimer / textTimeToFront;
              if (textTimer > textTimeToFront) 
              {
                textTimer = 0;
                textPhase += 1;
              }
              break;
            }
          case 3: {
              if (textTimer > textTimeAtPark) 
              {
                textTimer = 0;
                textPhase = 0;
                textIx += 1
                if (textIx >= message.length)
                {
                  textIx = 0;
                }
                text.text = message[textIx]; 
                text.x = textParkPosition;

              }
              break;
            }
          default:
          break;

        }

        for (let i = 0; i < flakes.length; i++)
        {
          const flake = flakes[i];
          flake.y += 1e-1*ticker.elapsedMS*flake.speed;
          flake.x += -0.5 + Math.random();
          if (flake.y > 800) {
            flake.x = getRandomInt(800);
            flake.y = 0
          }
        }

        currentTime += ticker.elapsedMS
        mikkoSprite.y = 120 + Math.sin(currentTime*5e-4*Math.PI*2.0)*15;
        mikkoSprite.x = Math.cos(currentTime*1e-4*Math.PI*2.0)*15;
        mountainSprite.x += mountainDir;
        mountainSprite.y = -120 + Math.sin(Math.sin(currentTime*1e-4*Math.PI*2.0)*Math.PI)*70;
        if (mountainSprite.x > 0)
        {
          mountainDir *= -1;
        }
        if (mountainSprite.x < -2000)
        {
          mountainDir *= -1;
        }
        app.render();
        requestAnimationFrame(update);
      }
    </script>
  </body>
</html>
